<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#8d99ae">
<meta name="msapplication-navbutton-color" content="#8d99ae">
<meta name="apple-mobile-web-app-status-bar-style" content="#8d99ae">

<meta name="keywords" content="freebsd, docker, virtualization">


<meta property="og:title" content="Docker on Freebsd | Matías Aguirre">

<meta property="og:description" content="Running Docker on FreeBSD is not an easy ride, but it&#39;s doable">

<meta property="og:site_name" content="Matías Aguirre" />

<meta property="og:url" content="/posts/docker-on-freebsd/" />

<meta property="og:locale" content="en-us">


  
  
  
  <meta property="og:type" content="article" />
  <meta property="article:modified_time" content="2017-09-07 12:50:46 -0300 UYT" />
  <meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2017-09-07T12:50:46-03:00" />
  
    <meta property="article:tag" content="docker" />
  
    <meta property="article:tag" content="freebsd" />
  
    <meta property="article:tag" content="virtualization" />
  

<meta property="og:image" content="/me-small.png" />
<meta property="og:image:url" content="/me-small.png" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image:src" content="/me-small.png" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Docker on Freebsd"/>
<meta name="twitter:description" content="Running Docker on FreeBSD is not an easy ride, but it&#39;s doable"/>
<meta name="twitter:domain" content="Matías Aguirre"/>
<meta name="twitter:creator" content="Matías Aguirre"/>

<title>Docker on Freebsd | Matías Aguirre</title>


  <link rel="stylesheet" href="/css/style.css">


<link rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
      integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN"
      crossorigin="anonymous">


  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


  </head>
  <body>
    <section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="/"><h1 class="title is-4">Matías Aguirre</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/omab">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/linuxaddict">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://uy.linkedin.com/in/matiasaguirre">
            <span class="icon">
              <i class="fa fa-linkedin"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>


    <section class="section">
      <div class="container">
        <h2 class="subtitle is-6">September 7, 2017</h2>
        <h1 class="title">Docker on Freebsd</h1>
        <div class="subtitle is-6">
          
            <code>docker</code>
          
            <code>freebsd</code>
          
            <code>virtualization</code>
          
        </div>
        <div class="content">
          

<p>Docker on FreeBSD is not an easy ride, several attempts failed to
bring the popular container platform to this operating system.
We have the <a href="https://github.com/kvasdopil/docker">outdated port</a>,
<a href="https://github.com/3ofcoins/jetpack">jetpack</a>, and the popular
<a href="https://wiki.freebsd.org/Docker">Docker on Freebsd</a> wiki article. But
still, the process is not easy, and prone to failures.</p>

<p><a href="https://www.freebsd.org/doc/handbook/jails.html">Jails</a> is the
popular choice to isolate applications in FreeBSD, it&rsquo;s been a part of
the operating system since FreeBSD 4.X, so it&rsquo;s very robust and has a
long story already. That could explain the lack of demand for
supporting <code>docker</code> on a native or close-to native way.</p>

<p>But docker is very popular these days and can&rsquo;t be ignored.</p>

<h2 id="looking-for-a-working-setup">Looking for a working setup</h2>

<p>Through this process I&rsquo;ve experienced many problems trying to setup a
Docker environment. Options I&rsquo;ve tried are:</p>

<ul>
<li><code>docker-freebsd</code> port, but <code>docker-compose</code> failes to connect and
communicate with the docker daemon, also the <code>docker</code> client
experiences API version mismatches. Even telling it to ignore the
version difference doesn&rsquo;t work.</li>
<li><code>bhyve</code> with <code>boot2docker</code>, <code>coreos</code>, <code>rancheros</code> machines, but these
images refused to boot. In the end, I got <code>boot2docker</code> to work.</li>
<li><code>bhyve</code> with a <code>debian</code> guest, this actually worked, but I was more
interested on using <code>boot2docker</code> or another dedicated OS.</li>
<li><code>docker-machine</code>, but the <code>virtualbox</code> guest fails to get an IP from
the host-only interface. The machine is up, you can ssh to it
through <code>docker-machine ssh</code>, but the second interface expected by
<code>docker-machine create</code> never gets an IP.</li>
</ul>

<p>Using <code>docker-machine</code> seems to be the best option today. For this to
happen, first we needed <code>boot2docker</code> up and running on a virtual
machine.</p>

<h3 id="getting-boot2docker-to-run">Getting boot2docker to run</h3>

<p>There are a few options to run <code>boot2docker</code> on <code>FreeBSD</code>:</p>

<ul>
<li><code>docker-machine</code></li>
<li>Virtualbox (<code>VBoxManage</code>, <code>vagrant</code>)</li>
<li>Bhyve (<code>bhyve</code>, <code>chyve</code>, <code>iohyve</code>, <code>vm-bhyve</code>)</li>
</ul>

<h4 id="docker-machine">docker-machine</h4>

<p><strong>Requirements</strong>: <code>docker-machine</code>, <code>docker</code>, <code>virtualbox-ose</code></p>

<p><code>docker-machine</code> aims to setup a working docker environment, for that
it depends on docker running on another host accessible by it&rsquo;s public
IP address. The remote host could be another Linux server, a virtual
machine running Linux, even a DigitalOcean droplet or similar
provider. There are <a href="https://docs.docker.com/machine/drivers/">many drivers supported</a>.</p>

<p>To create a machine use the <code>create</code> command (this defaults to virtualbox in FreeBSD):</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> docker-machine create default
<span class="go">Running pre-create checks...</span>
<span class="go">Creating machine...</span>
<span class="go">(default) Copying /home/omab/.docker/machine/cache/boot2docker.iso to /home/omab/.docker/machine/machines/default/boot2docker.iso...</span>
<span class="go">(default) Creating VirtualBox VM...</span>
<span class="go">(default) Creating SSH key...</span>
<span class="go">(default) Starting the VM...</span>
<span class="go">(default) Check network to re-create if needed...</span>
<span class="go">(default) Waiting for an IP...</span>
<span class="go">Waiting for machine to be running, this may take a few minutes...</span>
<span class="go">Detecting operating system of created instance...</span>
<span class="go">Waiting for SSH to be available...</span>
<span class="go">Detecting the provisioner...</span>
<span class="go">Provisioning with boot2docker...</span>
<span class="go">Copying certs to the local machine directory...</span>
<span class="go">Copying certs to the remote machine...</span>
<span class="go">Error creating machine: Error running provisioning: Could not find matching IP for MAC address 080027669f2d</span>

<span class="gp">$</span> docker-machine ls
<span class="go">NAME                ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS</span>
<span class="go">default             -        virtualbox   Running                 Unknown   Could not find matching IP for MAC address 080027669f2d</span>
</code></pre></div>


<p><strong>Conclusion:</strong> Using purely <code>docker-machine</code> didn&rsquo;t work, the guest
virtual machine never gets an ip from the host-only interface.</p>

<h4 id="virtualbox-vagrant">Virtualbox + Vagrant</h4>

<p><strong>Requirements</strong>: <code>docker-machine</code>, <code>docker</code>, <code>virtualbox</code>, <code>vagrant</code></p>

<p>Since <code>docker-machine</code> uses <code>virtualbox</code>, then using it directly
seemed reasonable. For that, I&rsquo;ll use <a href="https://www.vagrantup.com/">vagrant</a>
since it simplifies the task.</p>

<p>Using the following <code>Vagrantfile</code> I was able to get a <code>boot2docker</code>
instance running:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="no">Vagrant</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">box</span> <span class="o">=</span> <span class="s2">&quot;AlbanMontaigu/boot2docker&quot;</span>

  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="s2">&quot;public_network&quot;</span>

  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="s2">&quot;forwarded_port&quot;</span><span class="p">,</span>
                    <span class="ss">:guest</span> <span class="o">=&gt;</span> <span class="mi">2375</span><span class="p">,</span>
                    <span class="ss">:host</span> <span class="o">=&gt;</span> <span class="mi">2375</span>

  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">provider</span> <span class="s2">&quot;virtualbox&quot;</span> <span class="k">do</span> <span class="o">|</span><span class="n">vb</span><span class="o">|</span>
    <span class="n">vb</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">vb</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;boot2docker-vm&quot;</span>
    <span class="n">vb</span><span class="o">.</span><span class="n">cpus</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Once <code>boot2docker</code> is up, all that&rsquo;s pending to do is tell
<code>docker-machine</code> to use that instance. That&rsquo;s possible with the
<a href="https://docs.docker.com/machine/drivers/generic/">generic driver</a>:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> docker-machine create <span class="se">\</span>
    --driver generic <span class="se">\</span>
    --generic-ip-address <span class="m">127</span>.0.0.1 <span class="se">\</span>
    --generic-ssh-port <span class="m">2222</span> <span class="se">\</span>
    --generic-ssh-user docker <span class="se">\</span>
    --generic-ssh-key ~/.vagrant.d/insecure_private_key <span class="se">\</span>
    boot2docker-vbox
<span class="go">Running pre-create checks...</span>
<span class="go">Creating machine...</span>
<span class="go">(boot2docker-vbox) Importing SSH key...</span>
<span class="go">(boot2docker-vbox) Couldn&#39;t copy SSH public key : unable to copy ssh key: open /home/omab/.vagrant.d/insecure_private_key.pub: no such file or directory</span>
<span class="go">Waiting for machine to be running, this may take a few minutes...</span>
<span class="go">Detecting operating system of created instance...</span>
<span class="go">Waiting for SSH to be available...</span>
<span class="go">Detecting the provisioner...</span>
<span class="go">Provisioning with boot2docker...</span>
<span class="go">Copying certs to the local machine directory...</span>
<span class="go">Copying certs to the remote machine...</span>
<span class="go">Setting Docker configuration on the remote daemon...</span>
<span class="go">Checking connection to Docker...</span>
<span class="go">Docker is up and running!</span>
<span class="go">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env boot2docker-vbox</span>

<span class="gp">$</span> docker-machine ls
<span class="go">NAME                ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER        ERRORS</span>
<span class="go">boot2docker-vbox    -        generic   Running   tcp://127.0.0.1:2376               v17.07.0-ce</span>
</code></pre></div>


<p>To use it, first enable the environment:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">#</span> this will <span class="nb">export</span> a few DOCKER_* environment variables
<span class="gp">$</span> <span class="nb">eval</span> <span class="k">$(</span>docker-machine env boot2docker-vbox<span class="k">)</span>

<span class="gp">$</span> docker run --rm hello-world
<span class="go">Unable to find image &#39;hello-world:latest&#39; locally</span>
<span class="go">latest: Pulling from library/hello-world</span>
<span class="go">b04784fba78d: Pull complete</span>
<span class="go">Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</span>
<span class="go">Status: Downloaded newer image for hello-world:latest</span>

<span class="go">Hello from Docker!</span>
<span class="go">This message shows that your installation appears to be working correctly.</span>

<span class="go">To generate this message, Docker took the following steps:</span>
<span class="go"> 1. The Docker client contacted the Docker daemon.</span>
<span class="go"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span>
<span class="go"> 3. The Docker daemon created a new container from that image which runs the</span>
<span class="go">    executable that produces the output you are currently reading.</span>
<span class="go"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span>
<span class="go">    to your terminal.</span>

<span class="go">To try something more ambitious, you can run an Ubuntu container with:</span>
<span class="gp"> $</span> docker run -it ubuntu bash

<span class="go">Share images, automate workflows, and more with a free Docker ID:</span>
<span class="go"> https://cloud.docker.com/</span>

<span class="go">For more examples and ideas, visit:</span>
<span class="go"> https://docs.docker.com/engine/userguide/</span>
</code></pre></div>


<p>Those familiar with <code>Vagrant</code> know about the port-forwarding rules,
these rules let you expose a port in the guest to the host host. The
problem is that adding new ports requires a <code>reload</code> of the virtual
machine and that will take down all your running containers.</p>

<p>Using <a href="https://github.com/boot2docker/boot2docker/blob/master/doc/WORKAROUNDS.md#port-forwarding">VboxManage controlvm</a>
should overcome this limitation, but I haven&rsquo;t tested it yet. Another
option is to use a NAT interface, but if you find a way to make it
work, let me know.</p>

<p><strong>Conclusion:</strong> This setup works and it&rsquo;s highly recommended because
it&rsquo;s very simple to achieve.</p>

<h4 id="bhyve-iohyve">Bhyve + iohyve</h4>

<p><strong>Requirements</strong>: <code>docker-machine</code>, <code>docker</code>, <code>bhyve</code>, <code>iohyve</code></p>

<p>Given that <code>docker-machine</code> just expects the docker daemon to be
accessible at a given IP and port, we could use
<a href="https://www.freebsd.org/doc/handbook/virtualization-host-bhyve.html">bhyve</a>
to run <code>boot2docker</code>. For that we will be using
<a href="https://github.com/pr1ntf/iohyve">iohyve</a> to simplify the setup.</p>

<p><strong>Note:</strong> <code>boot2docker</code> runs in memory, it&rsquo;s not an installable
distribution, measures are needed in order to persist the docker
images.</p>

<ul>
<li>Let&rsquo;s create the machine</li>
</ul>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> sudo iohyve create boot2docker 16G
<span class="gp">$</span> sudo iohyve <span class="nb">set</span> boot2docker <span class="nv">os</span><span class="o">=</span>custom <span class="nv">loader</span><span class="o">=</span>grub-bhyve <span class="nv">ram</span><span class="o">=</span>2G
<span class="gp">$</span> sudo iohyve iso https://github.com/boot2docker/boot2docker/releases/download/v17.07.0-ce/boot2docker.iso
</code></pre></div>


<p>We need a custom <code>device.map</code> and <code>grub.cfg</code> files to make it boot
with the following content:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">#</span> cat &lt;&lt;EOF &gt; /iohyve/boot2docker/device.map
<span class="go">(hd0) /dev/zvol/zroot/iohyve/boot2docker/disk0</span>
<span class="go">(cd0) /iohyve/ISO/boot2docker.iso/boot2docker.iso</span>
<span class="go">EOF</span>

<span class="gp">#</span> cat &lt;&lt;EOF &gt; /iohyve/boot2docker/grub.cfg
<span class="go">linux (cd0)/boot/vmlinuz64 loglevel=3 user=docker nomodeset norestore base</span>
<span class="go">initrd (cd0)/boot/initrd.img</span>
<span class="go">boot</span>
<span class="go">EOF</span>
</code></pre></div>


<p>With those files in place we can proceed with the rest of the setup:</p>

<p><strong>Note:</strong> <code>boot2docker</code> default credentials are <code>docker:tcuser</code>.</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> sudo iohyve install boot2docker boot2docker.iso
<span class="gp">$</span> sudo iohyve console boot2docker
<span class="go">...</span>
<span class="go">VM booting messages</span>
<span class="go">...</span>

<span class="go">Core Linux</span>
<span class="go">boot2docker login: docker</span>
<span class="gp">                        #</span><span class="c1">#         .</span>
<span class="gp">                  #</span><span class="c1"># ## ##        ==</span>
<span class="gp">               #</span><span class="c1"># ## ## ## ##    ===</span>
<span class="go">           /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===</span>
<span class="go">      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~</span>
<span class="go">           \______ o           __/</span>
<span class="go">             \    \         __/</span>
<span class="go">              \____\_______/</span>
<span class="go"> _                 _   ____     _            _</span>
<span class="go">| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __</span>
<span class="go">| &#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &#39;__|</span>
<span class="go">| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |</span>
<span class="go">|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|</span>
<span class="go">Boot2Docker version 17.07.0-ce, build HEAD : 24e9d2f - Wed Aug 30 00:04:56 UTC 2017</span>
<span class="go">Docker version 17.07.0-ce, build 8784753</span>

<span class="gp">docker@boot2docker:~$</span>
</code></pre></div>


<ul>
<li>Setup the persistent storage</li>
</ul>

<p><code>boot2docker</code> will automatically mount the first partition it detects
with the label <code>boot2docker-data</code> or the first <code>ext[234]</code> partition into
<code>/var/lib/docker</code> and <code>/var/lib/boot2docker</code>. For that, we need to
prepare the partition in the attached disk.</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">#</span> create a Linux partition, save and <span class="nb">exit</span>
<span class="gp">$</span> sudo fdisk /dev/sda
<span class="gp">$</span> sudo mkfs.ext4 /dev/sda1
<span class="gp">$</span> sudo tune2fs -L boot2docker-data /dev/sda1
</code></pre></div>


<p><strong>Note:</strong> exit from the <code>cu</code> console by typing <code>~~.</code> or <code>~ Ctrl+d</code></p>

<p>Let&rsquo;s restart the machine:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> sudo iohyve stop boot2docker
<span class="gp">$</span> sudo iohyve start boot2docker
</code></pre></div>


<p>This time, the formatted partition will be mounted and changes will be
persisted. But first we need to tune the docker daemon a bit to work
in the machine. By default <code>runc</code> will call <code>root_pivot</code> to change the
root endpoint, but <code>root_pivot</code> doesn&rsquo;t work on <code>initrd</code> based systems.</p>

<p>There&rsquo;s no option to pass extra parameters from <code>dockerd</code> to <code>runc</code>,
so wrapping is the only solution at the moment:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> sudo iohyve console boot2docker
<span class="gp">#</span> login with docker user <span class="o">(</span>tcuser password<span class="o">)</span>
<span class="gp">$</span> sudo -s

<span class="gp">#</span> cat &lt;&lt;EOF &gt; /var/lib/boot2docker/etc/docker/daemon.json
<span class="go">{</span>
<span class="go">    &quot;default-runtime&quot;: &quot;runc-nopivot&quot;,</span>
<span class="go">    &quot;runtimes&quot;: {</span>
<span class="go">        &quot;runc-nopivot&quot;: {</span>
<span class="go">            &quot;path&quot;: &quot;/var/lib/boot2docker/etc/docker/runc-nopivot.sh&quot;</span>
<span class="go">        }</span>
<span class="go">    }</span>
<span class="go">}</span>
<span class="go">EOF</span>

<span class="gp">#</span> cat &lt;&lt;EOF &gt; /var/lib/boot2docker/etc/docker/runc-nopivot.sh
<span class="gp">#</span>!/bin/sh
<span class="go">args=\`echo &quot;\$@&quot; | sed &#39;s/create/create --no-pivot/&#39;\`</span>
<span class="go">/usr/local/bin/docker-runc \$args</span>
<span class="go">EOF</span>

<span class="gp">#</span> chmod +x /var/lib/boot2docker/etc/docker/runc-nopivot.sh

<span class="gp">#</span> /etc/init.d/docker restart
</code></pre></div>


<p>We can proceed to connect <code>docker-machine</code> with the virtual
machine. First grab the IP address with <code>ifconfig eth0</code> or <code>ip addr
show dev eth0</code>.</p>

<p>Let&rsquo;s authorize your ssh key to make the process easier:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> ssh-copy-id docker@192.168.1.156

<span class="gp">$</span> docker-machine create <span class="se">\</span>
    --driver generic <span class="se">\</span>
    --generic-ip-address <span class="m">192</span>.168.1.156 <span class="se">\</span>
    --generic-ssh-user docker
<span class="go">    boot2docker-bhyve</span>

<span class="gp">$</span> docker-machine ls
<span class="go">NAME                ACTIVE   DRIVER    STATE     URL                       SWARM   DOCKER        ERRORS</span>
<span class="go">boot2docker-bhyve   -        generic   Running   tcp://192.168.1.156:2376          v17.07.0-ce</span>
</code></pre></div>


<p>Now we can use docker:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> <span class="nb">eval</span> <span class="k">$(</span>docker-machine env boot2docker-bhyve<span class="k">)</span>

<span class="gp">$</span> docker run --rm hello-world
<span class="go">Unable to find image &#39;hello-world:latest&#39; locally</span>
<span class="go">latest: Pulling from library/hello-world</span>
<span class="go">b04784fba78d: Pull complete</span>
<span class="go">Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f</span>
<span class="go">Status: Downloaded newer image for hello-world:latest</span>

<span class="go">Hello from Docker!</span>
<span class="go">This message shows that your installation appears to be working correctly.</span>

<span class="go">To generate this message, Docker took the following steps:</span>
<span class="go"> 1. The Docker client contacted the Docker daemon.</span>
<span class="go"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span>
<span class="go"> 3. The Docker daemon created a new container from that image which runs the</span>
<span class="go">    executable that produces the output you are currently reading.</span>
<span class="go"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span>
<span class="go">    to your terminal.</span>

<span class="go">To try something more ambitious, you can run an Ubuntu container with:</span>
<span class="gp"> $</span> docker run -it ubuntu bash

<span class="go">Share images, automate workflows, and more with a free Docker ID:</span>
<span class="go"> https://cloud.docker.com/</span>

<span class="go">For more examples and ideas, visit:</span>
<span class="go"> https://docs.docker.com/engine/userguide/</span>
</code></pre></div>


<p><strong>Conclusion:</strong> This setup works, the bridged interface makes
interacting with the containers easier since no port-forwarding rules
are needed, it demands some work to setup, but in the end it behaves
great.</p>

<h2 id="the-big-problem">The big problem</h2>

<p>Filesystem synchronization is a feature I find vital for any usable
work setup. It&rsquo;s very important that the codebase being worked is up
to date inside the running container or virtual machine, this makes
applications restart and code reload easier, even automated.</p>

<p>This isn&rsquo;t a new problem, the same used to happen with <code>Virtualbox</code>
and the very slow <code>vboxsf</code>, there are <code>vagrant</code> plugins that
workaround this problem but none proved to be fast enough.</p>

<p>Network solutions like <code>nfs</code> don&rsquo;t guarantee an immediate
synchronization or don&rsquo;t propagate filesystem events that happen in
the host machine.</p>

<h4 id="docker-sync">docker-sync</h4>

<p>Looking for solutions I came across <a href="https://github.com/EugenMayer/docker-sync/">docker-sync</a>,
this project looks to keep files in synchronized using different
approaches depending on the OS and the software available, while
aiming to be fast and no CPU intensive.</p>

<p><code>docker-sync</code> works by creating a container (depends on the strategy
selected) for each specified shareable resource, then synchronizes the
content into that container at <code>/app_sync</code> using the defined strategy
(<code>rsync</code>, <code>unison</code>, etc). Finally, the volumes created by this
container are used by your application.</p>

<p>The main drawback is that it depends on named volumes, so you can&rsquo;t
used <code>-v .:/code</code> or <code>- .:/code</code> in your <code>docker-compose.yml</code>
file. But it integrates with <code>docker-compose</code> to reduce the pain a
little.</p>

<p><strong>Note:</strong> FreeBSD support is still <a href="https://github.com/EugenMayer/docker-sync/pull/458">getting reviewed</a>
at the time of this writing.</p>

<p>Here&rsquo;s an example of a <code>docker-sync.yml</code> file:</p>

<div class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span></span><span class="l l-Scalar l-Scalar-Plain">version</span><span class="p p-Indicator">:</span> <span class="s">&quot;2&quot;</span>

<span class="l l-Scalar l-Scalar-Plain">options</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">verbose</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">true</span>
  <span class="l l-Scalar l-Scalar-Plain">project_root</span><span class="p p-Indicator">:</span> <span class="s">&#39;pwd&#39;</span>

<span class="l l-Scalar l-Scalar-Plain">syncs</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">code-sync</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">sync_strategy</span><span class="p p-Indicator">:</span> <span class="s">&#39;rsync&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">src</span><span class="p p-Indicator">:</span> <span class="s">&#39;.&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">sync_host_port</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">10871</span>
</code></pre></div>


<p>To start the sync, just run:</p>

<div class="highlight"><pre><code class="language-shell-session" data-lang="shell-session"><span></span><span class="gp">$</span> docker-sync start
<span class="go">          ok  Starting rsync for sync code-sync</span>
<span class="go">          ok  code-sync container not running</span>
<span class="go">          ok  creating code-sync container</span>
<span class="go">     command  docker run -p &#39;10871:873&#39; -v code-sync:/app_sync   -e VOLUME=/app_sync -e TZ=${TZ-`readlink /etc/localtime | sed -e &#39;s,/usr/share/zoneinfo/,,&#39;`} --name code-sync -d eugenmayer/rsync</span>
<span class="go">          ok  code-sync: starting initial sync of /usr/home/omab/app</span>
<span class="go">     command  rsync -ap &#39;/usr/home/omab/app&#39; rsync://192.168.1.156:10871/volume</span>
<span class="go">          ok  Synced /usr/home/omab/app</span>
<span class="go">      output</span>
<span class="go">     success  Rsync server started</span>
<span class="go">     command  rsync -ap &#39;/usr/home/omab/d/app&#39; rsync://192.168.1.156:10871/volume</span>
<span class="go">          ok  Synced /usr/home/omab/app</span>
<span class="go">      output</span>
<span class="go">     success  Starting Docker-Sync in the background</span>
</code></pre></div>


<h2 id="jocker-and-jocker-compose">jocker and jocker-compose</h2>

<p>I&rsquo;m currently working on two projects looking to bring some of the
simplicity of <code>docker</code> and <code>docker-compose</code> into the <code>jails</code> world.</p>

<p>The two tools named <code>jocker</code> and <code>jocker-compose</code> (names selected on
purpose) aim to work in similar ways than their docker counterparts,
but everything is based on <code>jails</code> and <a href="https://erdgeist.org/arts/software/ezjail/#flavours">ezjail flavours</a>.</p>

<p>This is pretty green stuff yet, specially the compose
part. Repositories are at <a href="https://github.com/omab/jocker">jocker</a> and
<a href="https://github.com/omab/jocker-compose">jocker-compose</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Using <code>docker</code> in <code>FreeBSD</code> is not impossible, it&rsquo;s not a very easy
task, but still, it&rsquo;s doable. Recommended options for quick setup is
<code>Vagrant + boot2docker + docker-machine</code>, if you prefer native
virtualization solutions, then go for <code>bhyve/iohyve + boot2docker +
docker-machine</code>. Use <code>docker-sync</code> to keep your code synchronized in
the container.</p>

        </div>
      </div>
    </section>

    

    <section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/omab">Matías Aguirre</a> 2017</p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/ruby.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/bash.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


  </body>
</html>
